---
title: Untitled
subtitle: "Subtitle with [**EMPHASIS**]{style='color:#3595ac;'} here"
description: Subtitle with emphasis here
format:
  360-embed-html: default
author: James Goldie
date: last-modified
resources:
  # - news-heat-postcodes-featuremedia.png
  - style.json
  - tiles/postcodes/*
  - tiles/postcodes/*/*/*.pbf
  # - font/*
  # - font/*/*
---

{{< include _popup-buttons.qmd >}}

```{ojs}
//| label: libraries

r = require.alias({
  maplibregl: "maplibre-gl@2.1.9/dist/maplibre-gl.js",
  // h3: {},
  // deck: "deck.gl@latest/dist.min.js"
});

maplibregl = r("maplibregl").catch(() => window["maplibregl"]);
// deck = r("deck");
```

```{ojs}
//| label: map

/* this is a bit different to regular mapbox/maplibre instantiation
   it lets have the map react to other values in the document, like
   a button or a timer, without reinstantiating!
   (based on https://observablehq.com/@tmcw/using-mapbox-gl-js) */
   
viewof map = {
  let container = html`<div style="position: absolute; left: 0; top: 0; height: 100vh; width: 100%;" />`;

  // Give the container dimensions.
  yield container;

  // Create the \`map\` object with the mapboxgl.Map constructor, referencing
  // the container div
  let map = new maplibregl.Map({
    container,
    center: [133, -28],
    zoom: 3.8,
    antialias: true,
    style: "style.json"
  });

  // on map load:
  // - dispatch its value back to ojs
  // - add a prop to the layer that adds/removes a popup from the map
  //   (we can't do this on initial layer def because the map isn't ready yet)
  map.on("load", () => {
    container.value = map;
    container.dispatchEvent(new CustomEvent("input"));

    map.addSource("postcodes", {
      "url": "tiles/postcodes/tiles.json",
      "type": "vector",
      "promoteId": "POA_NAME_2021"
    });

    map.addLayer({
      id: "postcode-colors",
      source: "postcodes",
      "source-layer": "postcodeswgs84",
      type: "fill",
      paint: {
        "fill-color":
          ["case", ["==", ["feature-state", "ensmean"], null], "#0000ff",
            [
              "interpolate",
              ["linear"],
              ["feature-state", "ensmean"],
              0,   "#ffffb2",
              73,  "#fed976",
              146, "#feb24c",
              219, "#fd8d3c",
              292, "#f03b20",
              366, "#bd0026"
            ]
          ]
      }
    })
  });

}
```


```{ojs}
//| label: get-data
projections = FileAttachment("/data/news-stats-postcodes-long.csv")
  .csv({ typed: true });

// filter data here (note postcodes need to be re-padded b/c observable's type
// inference makes them numeric)
filteredProjections = projections
  .filter(
    d => (d.file_grid == "AUS-44") && (d.file_scenario == "historical"))
  .map(d => ({ ...d, postcode: String(d.geo_name).padStart(4, "0") }))
```

```{ojs}
//| label: update-map

// fills = map.getLayer("postcode-colors")

// pass the new data to the tiles whenever it re-filters from user interaction
filteredProjections.forEach(row => {
  map.setFeatureState(
    {
      source: "postcodes",
      sourceLayer: "postcodeswgs84",
      id: row.postcode,
    },
    {
      ensmean: row.ensmean,
      ensmax: row.ensmax,
      ensmin: row.ensmin
    }
  );

  // console.log(map.getFeatureState("postcodes", {
  //   sourceLayer: "postcodeswgs84",
  //   id: row.postcode
  // }));
});
```


{{< include _popup-dialogs.qmd >}}
