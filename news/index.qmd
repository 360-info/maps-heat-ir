---
title: Future heat
# subtitle: "Subtitle with [**EMPHASIS**]{style='color:#3595ac;'} here"
description: Subtitle with emphasis here
format:
  360-embed-html: default
css:
  - https://cdn.jsdelivr.net/npm/maplibre-gl@2.1.9/dist/maplibre-gl.css
resources:
  # - news-heat-postcodes-featuremedia.png
  - style.json
  - stripes.png
  - tiles/postcodes/*
  - tiles/postcodes/*/*/*.pbf
  # - font/*
  # - font/*/*
---

```{ojs}
micro = require("micromodal@0.4.10")
micro.init({
  awaitOpenAnimation: true,
  awaitCloseAnimation: true
});
```

{{< include _popup-buttons.qmd >}}

```{ojs}
//| label: libraries

r = require.alias({
  maplibregl: "maplibre-gl@2.1.9/dist/maplibre-gl.js",
});

maplibregl = r("maplibregl").catch(() => window["maplibregl"]);
```

```{ojs}
//| label: map

/* this is a bit different to regular mapbox/maplibre instantiation
   it lets have the map react to other values in the document, like
   a button or a timer, without reinstantiating!
   (based on https://observablehq.com/@tmcw/using-mapbox-gl-js) */
   
viewof map = {
  let container = html`<div style="position: absolute; left: 0; top: 0; height: 100vh; width: 100%;" />`;

  // Give the container dimensions.
  yield container;

  // Create the \`map\` object with the mapboxgl.Map constructor, referencing
  // the container div
  let map = new maplibregl.Map({
    container,
    // center: [133, -28],
    bounds: [[111, -46], [155, -9]],
    // zoom: 3.8,
    // minZoom: 1,
    maxZoom: 14,
    antialias: true,
    style: "style.json",
    attributionControl: false,
    maxBounds: [[105, -48], [160, -5]],
  });

  // on map load:
  // - dispatch its value back to ojs
  // - add a prop to the layer that adds/removes a popup from the map
  //   (we can't do this on initial layer def because the map isn't ready yet)
  map.on("load", () => {
    container.value = map;
    container.dispatchEvent(new CustomEvent("input"));

    map.addSource("postcodes", {
      "url": "tiles/postcodes/tiles.json",
      "type": "vector",
      "promoteId": "POA_NAME21"
    });

    // this layer shades all postcodes
    map.addLayer({
      id: "postcode-colors",
      source: "postcodes",
      "source-layer": "postcodeswgs84",
      type: "fill"
    });

    // add pattern for focused postcodes
    map.loadImage("stripes.png", function(err, image) {
      if (err) throw err;
      map.addImage("focusStripes", image);
    });

    // TODO - add an extra stripey layer on top for the highlighted postcode
    // map.addLayer({
    //   id: "postcode-focused",
    //   source: "postcodes",
    //   "source-layer": "postcodeswgs84",
    //   type: "fill",
    //   "filter": ["==", ["feature-state", "isFocus"], true],
    //     "paint": {
    //         "fill-pattern": "focusStripes",
    //     }
    // });

    /* popup */

    const popup = new maplibregl.Popup({
      closeButton: false,
      closeOnClick: false,
      className: "map-popup"
    });

    map.on("click", "postcode-colors", function(e) {
      // Change the cursor style as a UI indicator.
      map.getCanvas().style.cursor = "pointer";

      const coordinates = e.features[0].geometry.coordinates;

      const target = coordinates[0][0] ?
        coordinates[0][0] : coordinates[0][0][0];

      // either coordinates[0][0] (if it's Array(2)) or coordinates[0][0][0]
      // console.log(e.features[0].properties.POA_NAME21)
      var description =
        e.features[0].properties.POA_NAME21 + ": " +
        e.features[0].state.ensmin + " to " +
        e.features[0].state.ensmax + " 35째C+ days";
      
      // Ensure that if the map is zoomed out such that multiple
      // copies of the feature are visible, the popup appears
      // over the copy being pointed to.
      // while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
      // coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
      // }
      
      // Populate the popup and set its coordinates
      // based on the feature found.
      popup.setLngLat(coordinates).setHTML(description).addTo(map);
    });
      
    map.on("mouseleave", "places", function () {
      map.getCanvas().style.cursor = "";
      popup.remove();
    });

  });


}
```

```{ojs}
//| label: controls
//| classes: inputForm

viewof selectedPeriod = Inputs.radio(["1995", "2030", "2050"], { value: "1995" })

viewof selectedScenario = Inputs.radio(
  new Map([
    ["Medium emissions", "rcp45diff"],
    ["High emissions", "rcp85diff"]
  ]),
  { value: "rcp45diff", disabled: selectedPeriod == "1995" })

// override scenario with historical if 1995 is selected
actualScenario = (selectedPeriod == "1995" ? "historical" : selectedScenario)
```

```{ojs}
//| label: area-search-controls
//| classes: areaInputForm

// start with a search box to narrow postcodes and suburbs down
viewof areaSearch = Inputs.search(postcodeSuburbMap, {
  placeholder: "Enter your postcode or suburb"
});

// display a menu of results and a search button when we're down to 30 results

viewof selectedPostcode =
  areaSearch.length > 0 && areaSearch.length < 100 ?
    Inputs.select(areaSearch, {
      format: d => `${d.SAL_NAME21} (${d.POA_NAME21})`
    }) :
    md``

viewof goBtn =
  areaSearch.length > 0 && areaSearch.length < 100 ?
    Inputs.button(`Go`, {
      reduce: () => zoomToPostcode(selectedPostcode.POA_NAME21)
    }) :
  md``
```


```{ojs}
//| label: get-data
projections = FileAttachment("/data/news-stats-postcodes-short.csv")
  .csv({ typed: true });

postcodeSuburbMap = FileAttachment("/data/postcode-suburb-map.csv")
  .csv();
// postcodeList = FileAttachment("/data/postcode-list.csv").csv();

// filter data here (note postcodes need to be re-padded b/c observable's type
// inference makes them numeric)
filteredProjections = projections
  .filter(
    d =>
      (d.file_period == selectedPeriod) &&
      (d.file_scenario == actualScenario))
  .map(d => ({ ...d, postcode: String(d.geo_name).padStart(4, "0") }));
```

```{ojs}
//| label: update-map

yellowRedFill = [
  0,   "#ffffb2",
  5,   "#fed976",
  10,  "#feb24c",
  20,  "#fd8d3c",
  40,  "#f03b20",
  80,  "#bd0026"
]
yellowRedStroke = [
  0,   "#ffff46",
  5,   "#fdbf1a",
  10,  "#f68e01",
  20,  "#e86302",
  40,  "#bf240d",
  80,  "#8e001c"
]

rainbowFill = [
  0,   "#3288bd",
  7,   "#99d594",
  14,  "#e6f598",
  30,  "#ffffbf",
  90,  "#fee08b",
  180, "#fc8d59",
  366, "#d53e4f"
]
rainbowStroke = [
  0,   "#26668e",
  7,   "#5bbc53",
  14,  "#d0ec3e",
  30,  "#ffff4f",
  90,  "#fdc62a",
  180, "#fa5305",
  366, "#a92534"
]

// when the filtered data changes, rejoin it to the map tiles and update the
// colour scheme
updateMapData = {

  filteredProjections.forEach(row => {
    map.setFeatureState(
      {
        source: "postcodes",
        sourceLayer: "postcodeswgs84",
        id: row.postcode,
      },
      {
        ensmean: row.ensmean,
        ensmax: row.ensmax,
        ensmin: row.ensmin
      }
    );
  });

  if (actualScenario.endsWith("diff")) {
      // extra days in future: yellow-red
      console.log(actualScenario + ": switching to yellow-red")
      map.setPaintProperty("postcode-colors", "fill-color",
        ["case", ["==", ["feature-state", "ensmean"], null], "#666666",
          ["interpolate", ["linear"], ["feature-state", "ensmean"],
            ...yellowRedFill]
        ]);
      map.setPaintProperty("postcode-colors", "fill-outline-color",
        ["case", ["==", ["feature-state", "ensmean"], null], "#666666",
          ["interpolate", ["linear"], ["feature-state", "ensmean"],
            ...yellowRedStroke]
        ]);
    } else {
      // historical: diverging rainbow
      console.log(actualScenario + ": switching to rainbow")
      map.setPaintProperty("postcode-colors", "fill-color",
        ["case", ["==", ["feature-state", "ensmean"], null], "#666666",
          ["interpolate", ["linear"], ["feature-state", "ensmean"],
            ...rainbowFill]
        ]);
      map.setPaintProperty("postcode-colors", "fill-outline-color",
        ["case", ["==", ["feature-state", "ensmean"], null], "#666666",
          ["interpolate", ["linear"], ["feature-state", "ensmean"],
            ...rainbowStroke]
        ]);
  }

  // also set fill pattern if highlighted
  // map.setPaintProperty("postcode-colors", "fill-patterm",
  //     ["case", ["==", ["feature-state", "isFocus"], true],
  //       "focusStripes",
  //       // null?
  //     ]);


}
```

```{ojs}
//| label: zoom-to-postcode-fn
function zoomToPostcode(postcode) {

  // TODO - stop highlighting previously selected postcode
  
  // get the postcode's feature
  const targetPostcodeFeature = map.querySourceFeatures("postcodes", {
    sourceLayer: "postcodeswgs84",   // postcodeswgs84?
    filter: ["==", "POA_NAME21", postcode]
  });

  if (targetPostcodeFeature.length != 1) {
    console.error("Can only zoom to 1 postcode at a time, not ",
      targetPostcodeFeature.length);
  }

  // get the feature's geometry
  const geom = targetPostcodeFeature[0].geometry.coordinates[0];

  // reduce the geometry to bounds
  const postcodeBounds = geom.reduce(
    (accum, current) => accum.extend(current),        
    new maplibregl.LngLatBounds(geom[0], geom[0]));

  // zoom to postcode
  map.fitBounds(postcodeBounds, {
    padding: {top: 40, bottom:30, left: 10, right: 10},
    maxZoom: 12
  });

  // highlight postcode?
  map.setFeatureState(
    {
      source: "postcodes",
      sourceLayer: "postcodeswgs84",
      id: postcode,
    },
    { inFocus: true }
  );
  

  // display info panel
  setTimeout(micro.show("modal-focused-postcode"), 1000)

}
```

<!-- the panel with further postcode-specific information pops up as a modal -->

::::::: {#modal-focused-postcode .modal .micromodal-slide aria-hidden="true"}
:::::: {.modal__overlay tabindex="-1" data-micromodal-close="true"}
::::: {.modal__container role="dialog" aria-modal="true" aria-labelledby="modal-focused-postcode-title"}

<button class="modal__close" aria-label="Close modal" data-micromodal-close></button>

<header>
## ${selectedPostcode.POA_NAME21} {#modal-focused-postcode-title}
#### ${suburbsInPostcode}
</header>

:::: {#modal-focused-postcode-content}
```{ojs}
//| label: info-panel
// classes: focusPanel
focusedPostcodeProjections = projections
  .filter(
      d => d.geo_name == selectedPostcode.POA_NAME21)
    // .map(d => ({ ...d, postcode: String(d.geo_name).padStart(4, "0") }));

// which suburbs are in this postcode?
suburbsInPostcode = postcodeSuburbMap
  .filter(d => d.POA_NAME21 == selectedPostcode.POA_NAME21)
  .map(d => d.SAL_NAME21)
  .join(", ")

// display info as a table (just for dianostic purposes)
// viewof infoTable = Inputs.table(focusedPostcodeProjections)

// get the different scenarios out
figuresNow = focusedPostcodeProjections
  .filter(d => d.file_scenario == "historical")
figures2030Med = focusedPostcodeProjections
  .filter(d => d.file_scenario == "rcp45" && d.file_period == "2030")
figures2030MedDiff = focusedPostcodeProjections
  .filter(d => d.file_scenario == "rcp45diff" && d.file_period == "2030")
figures2050Med = focusedPostcodeProjections
  .filter(d => d.file_scenario == "rcp45" && d.file_period == "2050")
figures2050MedDiff = focusedPostcodeProjections
  .filter(d => d.file_scenario == "rcp45diff" && d.file_period == "2050")

figures2030High = focusedPostcodeProjections
  .filter(d => d.file_scenario == "rcp85" && d.file_period == "2030")
figures2030HighDiff = focusedPostcodeProjections
  .filter(d => d.file_scenario == "rcp85diff" && d.file_period == "2030")
figures2050High = focusedPostcodeProjections
  .filter(d => d.file_scenario == "rcp85" && d.file_period == "2050")
figures2050HighDiff = focusedPostcodeProjections
  .filter(d => d.file_scenario == "rcp85diff" && d.file_period == "2050")
```

**Recently:** up to **${figuresNow[0].ensmin} to ${figuresNow[0].ensmax}** 35째C+ days

Up to **an extra ${figures2030MedDiff[0].ensmin} to ${figures2030MedDiff[0].ensmax}** 35째C+ days in a typical year by 2030 under **medium emissions**, and **an extra ${figures2050MedDiff[0].ensmin} to ${figures2050MedDiff[0].ensmax}** by 2050.

Up to **an extra ${figures2030HighDiff[0].ensmin} to ${figures2030HighDiff[0].ensmax}** 35째C+ days in a typical year by 2030 under **High emissions**, and **an extra ${figures2050HighDiff[0].ensmin} to ${figures2050HighDiff[0].ensmax}** by 2050.

::::

:::::
::::::
:::::::

{{< include _popup-dialogs.qmd >}}
